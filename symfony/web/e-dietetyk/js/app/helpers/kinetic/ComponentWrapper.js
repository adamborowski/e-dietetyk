// Generated by CoffeeScript 1.6.3
(function() {
  Ext.define('app.helpers.kinetic.ComponentWrapper', {
    extend: 'app.helpers.kinetic.BaseWrapper',
    alias: 'kinetic.wrapper.component',
    config: {
      centerX: 0,
      centerY: 0,
      centerXRelative: true,
      centerYRelative: true,
      points: [],
      autoClose: true
    },
    updateLayout: function(x, y, w, h) {
      this.currentX = x;
      this.currentY = y;
      this.currentWidth = w;
      this.currentHeight = h;
      this.currentCenterX = this.getCenterX();
      if (this.getCenterXRelative()) {
        this.currentCenterX *= w;
      }
      this.currentCenterY = this.getCenterY();
      if (this.getCenterYRelative()) {
        this.currentCenterY *= h;
      }
      return this.callParent(arguments);
    },
    constructor: function(config, kineticObject) {
      var me, shapeConfig;
      if (kineticObject == null) {
        kineticObject = new Kinetic.Shape();
      }
      me = this;
      shapeConfig = {
        drawFunc: function(context) {
          var height, width;
          width = me.currentWidth;
          height = me.currentHeight;
          me.currentContext = context;
          context.beginPath();
          me.drawFunction(context, width, height);
          if (me.getAutoClose()) {
            context.closePath();
          }
          return context.fillStrokeShape(this);
        }
      };
      this.callParent([config, kineticObject]);
      kineticObject.setAttrs(shapeConfig);
    },
    drawFunction: function(ctx, width, height) {
      var p;
      p = this.getPoints();
      ctx.moveTo(p.a.x(), p.a.y());
      ctx.lineTo(p.b.x(), p.b.y());
      ctx.lineTo(p.c.x(), p.c.y());
      ctx.lineTo(p.d.x(), p.d.y());
    },
    setAttrs: function(attrs) {
      return this.kineticObject.setAttrs(attrs);
    },
    applyPoints: function(points) {
      var key, me, point;
      me = this;
      for (key in points) {
        point = points[key];
        point.x = function() {
          return this[0] * me.currentWidth + me.currentCenterX;
        };
        point.y = function() {
          return this[1] * me.currentHeight + me.currentCenterY;
        };
      }
      return points;
    },
    getPoint: function(point) {
      return {
        x: point[0] * this.currentWidth + this.currentCenterX,
        y: point[1] * this.currentHeight + this.currentCenterY
      };
    },
    normalizeX: function(x) {
      return x * this.currentWidth + this.currentCenterX;
    },
    normalizeY: function(y) {
      return y * this.currentHeight + this.currentCenterY;
    },
    bezier2: function(a, b) {
      return this.currentContext.quadraticCurveTo(a.x(), a.y(), b.x(), b.y());
    },
    bezier3: function(a, b, c) {
      a = this.getPoint(a);
      b = this.getPoint(b);
      c = this.getPoint(c);
      return this.currentContext.bezierCurveTo(a.x, a.y, b.x, b.y, c.x, c.y);
    },
    bezier3Relative: function(xa, ya, xb, yb, xc, yc) {
      return this.currentContext.bezierCurveTo(this.normalizeX(xa), this.normalizeY(ya), this.normalizeX(xb), this.normalizeY(yb), this.normalizeX(xc), this.normalizeY(yc));
    },
    deflection: function(aX, aY, bX, bY, balance) {
      var controlX, controlY, middleX, middleY, px, py, vecX, vecY;
      middleX = (aX + bX) / 2;
      middleY = (aY + bY) / 2;
      vecX = bX - middleX;
      vecY = bY - middleY;
      px = -vecY;
      py = +vecX;
      controlX = middleX + px * balance;
      controlY = middleY + py * balance;
      return this.currentContext.quadraticCurveTo(controlX, controlY, bX, bY);
    },
    deflectionPoint: function(a, b, balance) {
      var aX, aY;
      aX = a.x();
      aY = a.y();
      return this.deflection(aX, aY, b.x(), b.y(), balance);
    }
  });

}).call(this);

//# sourceMappingURL=ComponentWrapper.map
