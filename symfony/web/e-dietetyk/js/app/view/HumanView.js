// Generated by CoffeeScript 1.6.3
(function() {
  Ext.define('app.view.HumanView', {
    extend: 'app.helpers.CanvasWrapper',
    config: {
      values: {
        isMale: true,
        age: 22,
        minAge: 10,
        maxAge: 80,
        weight: 80,
        minWeight: 30,
        maxWeight: 200,
        height: 175,
        minHeight: 0,
        maxHeight: 220,
        waistline: 80,
        minWaistLine: 50,
        maxWaistLine: 140,
        hipSize: 88,
        minHipSize: 50,
        maxHipSize: 130
      },
      drawing: {
        corps: {
          fill: "#444444",
          strokeWidth: 8,
          strokeStyle: "#666666",
          lineJoin: 'round',
          lineCap: 'round',
          minHeight: 70,
          maxHeight: 270,
          maxWidth: 100,
          armNarrow: 53,
          maxSpace: 100,
          maxBottomNarrow: 40
        }
      }
    },
    constructor: function(config) {
      if (config == null) {
        config = {};
      }
      this.callParent(arguments);
      this.cx = this.canvas.getContext('2d');
      this.params = {
        symmetryLine: null,
        corps: {
          A: null,
          B: null,
          C: null,
          D: null,
          E: null,
          F: null,
          G: null,
          H: null,
          I: null,
          J: null,
          K: null,
          L: null
        }
      };
    },
    normalize: function(name, newMin, newMax) {
      var maxVal, minVal, val, values;
      if (newMin == null) {
        newMin = null;
      }
      if (newMax == null) {
        newMax = null;
      }
      values = this.getValues();
      val = values[name];
      maxVal = values['max' + name.charAt(0).toUpperCase() + name.slice(1)];
      minVal = values['min' + name.charAt(0).toUpperCase() + name.slice(1)];
      if (newMax != null) {
        return (val - minVal) / (maxVal - minVal) * (newMax - newMin) + newMin;
      }
      return (val - minVal) / (maxVal - minVal);
    },
    calculateParams: function() {
      var bottomBound, dr, dynamicNarrow, leftBound, leftSpaceLine, rightBound, rightSpaceLine, symLine, topBound, weightRatio;
      dr = this.getDrawing();
      symLine = this.params.symmetryLine = 0;
      weightRatio = this.normalize('weight');
      leftSpaceLine = symLine - weightRatio * dr.corps.maxSpace - 30;
      rightSpaceLine = symLine + weightRatio * dr.corps.maxSpace + 30;
      leftBound = symLine - 90;
      rightBound = symLine + 90;
      topBound = 0 - dr.corps.maxHeight / 2;
      bottomBound = 0 + dr.corps.maxHeight / 2;
      dynamicNarrow = weightRatio * dr.corps.maxBottomNarrow;
      this.params.corps.A = {
        x: leftBound + dynamicNarrow / 2,
        y: bottomBound
      };
      this.params.corps.B = {
        x: leftBound + dr.corps.armNarrow,
        y: topBound
      };
      this.params.corps.C = {
        x: rightBound - dr.corps.armNarrow,
        y: topBound
      };
      this.params.corps.D = {
        x: rightBound - dynamicNarrow / 2,
        y: bottomBound
      };
      this.params.corps.E = {
        x: leftSpaceLine,
        y: 0
      };
      this.params.corps.F = {
        x: rightSpaceLine,
        y: 0
      };
      this.params.corps.G = {
        x: leftSpaceLine + dynamicNarrow,
        y: bottomBound
      };
      this.params.corps.H = {
        x: leftSpaceLine,
        y: topBound
      };
      this.params.corps.I = {
        x: rightSpaceLine,
        y: topBound
      };
      this.params.corps.J = {
        x: rightSpaceLine - dynamicNarrow,
        y: bottomBound
      };
      this.params.corps.K = {
        x: symLine,
        y: topBound + 20
      };
      return this.params.corps.L = {
        x: symLine,
        y: bottomBound - 20
      };
    },
    bezier: function(pa, pb) {
      this.cx.save();
      this.cx.quadraticCurveTo(pa.x, pa.y, pb.x, pb.y);
      this.cx.lineStyle = 'black';
      this.cx.fillStyle = 'white';
      this.cx.lineWidth = 1;
      this.cx.fillRect(pa.x - 2, pa.y - 2, 4, 4);
      this.cx.strokeRect(pa.x - 2, pa.y - 2, 4, 4);
      return this.cx.restore();
    },
    bezier4: function(pax, pay, pbx, pby) {
      return this.bezier({
        x: pax,
        y: pay
      }, {
        x: pbx,
        y: pby
      });
    },
    render: function(w, h) {
      if (w == null) {
        w = this.getWidth();
      }
      if (h == null) {
        h = this.getHeight();
      }
      this.w = w;
      this.h = h;
      this.calculateParams();
      this.cx.save();
      this.cx.clearRect(0, 0, w, h);
      this.cx.translate(this.w / 2, this.h / 2);
      this.renderHand();
      this.renderCorps();
      return this.cx.restore();
    },
    renderCorps: function() {
      var dr, heightRatio, pc;
      this.cx.save();
      pc = this.params.corps;
      dr = this.getDrawing();
      this.cx.fillStyle = dr.corps.fill;
      this.cx.lineStyle = dr.corps.strokeStyle;
      this.cx.lineWidth = dr.corps.strokeWidth;
      this.cx.lineJoin = dr.corps.lineJoin;
      this.cx.lineCap = dr.corps.lineCap;
      heightRatio = this.normalize('height');
      this.cx.save();
      this.cx.scale(1, heightRatio);
      this.cx.beginPath();
      this.cx.moveTo(pc.A.x, pc.A.y);
      this.bezier(pc.E, pc.B);
      this.bezier(pc.K, pc.C);
      this.bezier(pc.F, pc.D);
      this.bezier(pc.L, pc.A);
      this.cx.fill();
      this.cx.restore();
      this.cx.stroke();
      return this.cx.restore();
    },
    renderHand: function() {
      var p1, p2;
      this.cx.save();
      this.cx.fillStyle = 'green';
      this.cx.translate(this.params.corps.B.x, this.params.corps.B.y);
      this.cx.rotate(Math.PI * 1 / 4);
      p1 = 20;
      p2 = 130;
      this.cx.beginPath();
      this.cx.moveTo(-p1, 0);
      this.bezier4(-p1, p2, 0, p2);
      this.bezier4(p1, p2, p1, 0);
      this.cx.closePath();
      this.cx.fill();
      this.cx.stroke();
      return this.cx.restore();
    }
  });

}).call(this);

//# sourceMappingURL=HumanView.map
