// Generated by CoffeeScript 1.6.3
(function() {
  Ext.define('app.helpers.kinetic.ShapeWrapper', {
    config: {
      initialAttrs: {
        fill: "#00D2FF",
        stroke: "black",
        strokeWidth: 4,
        width: 100,
        height: 100,
        strokeScaleEnabled: false,
        strokeEnabled: true
      },
      points: {
        a: [0, 0],
        b: [1, 0],
        c: [1, 1],
        d: [0, 1]
      },
      margin: 0
    },
    constructor: function(config) {
      var me, shapeConfig;
      Ext.apply(this.getInitialAttrs(), config.initialAttrs);
      this.initConfig(config);
      this.callParent(arguments);
      me = this;
      shapeConfig = this.getInitialAttrs();
      shapeConfig.drawFunc = function(context) {
        var height, width;
        width = me.currentWidth = this.getWidth();
        height = me.currentHeight = this.getHeight();
        me.currentContext = context;
        context.beginPath();
        me.drawFunction(context, width, height);
        context.closePath();
        return context.fillStrokeShape(this);
      };
      this.kineticShape = new Kinetic.Shape(shapeConfig);
    },
    calculateBounds: function(width, height) {},
    normalize: function(point) {},
    drawFunction: function(ctx, width, height) {
      var p;
      p = this.getPoints();
      ctx.moveTo(p.a.x(), p.a.y());
      ctx.lineTo(p.b.x(), p.b.y());
      ctx.lineTo(p.c.x(), p.c.y());
      ctx.lineTo(p.d.x(), p.d.y());
    },
    setAttrs: function(attrs) {
      return this.kineticShape.setAttrs(attrs);
    },
    get: function() {
      return this.kineticShape;
    },
    applyPoints: function(points) {
      var key, maxx, maxy, me, minx, miny, point;
      minx = 0;
      miny = 0;
      maxx = 0;
      maxy = 0;
      me = this;
      for (key in points) {
        point = points[key];
        point.x = function() {
          return this[0] / me.boundsWithMargin.width * me.currentWidth;
        };
        point.y = function() {
          return this[1] / me.boundsWithMargin.height * me.currentHeight;
        };
        minx = Math.min(point[0], minx);
        maxx = Math.max(point[0], maxx);
        miny = Math.min(point[1], miny);
        maxy = Math.max(point[1], maxy);
      }
      this.bounds = {
        minx: minx,
        maxx: maxx,
        miny: miny,
        maxy: maxy,
        width: maxx - minx,
        height: maxy - miny
      };
      this.calculateBoundsWithMargin();
      return points;
    },
    calculateBoundsWithMargin: function() {
      var margin;
      margin = this.getMargin();
      if (margin == null) {
        return;
      }
      return this.boundsWithMargin = {
        minx: this.bounds.minx + margin.left,
        maxx: this.bounds.maxx - margin.right,
        miny: this.bounds.miny + margin.top,
        maxy: this.bounds.maxy - margin.bottom,
        width: this.bounds.width - margin.left - margin.right,
        height: this.bounds.height - margin.top - margin.bottom
      };
    },
    getPoint: function(point) {
      return {
        x: point[0] / this.boundsWithMargin.width * this.currentWidth,
        y: point[1] / this.boundsWithMargin.height * this.currentHeight
      };
    },
    bezier2: function(a, b) {
      return this.currentContext.quadraticCurveTo(a.x(), a.y(), b.x(), b.y());
    },
    bezier3: function(a, b, c) {
      a = this.getPoint(a);
      b = this.getPoint(b);
      c = this.getPoint(c);
      return this.currentContext.bezierCurveTo(a.x, a.y, b.x, b.y, c.x, c.y);
    },
    deflection: function(aX, aY, bX, bY, balance) {
      var controlX, controlY, middleX, middleY, px, py, vecX, vecY;
      middleX = (aX + bX) / 2;
      middleY = (aY + bY) / 2;
      vecX = bX - middleX;
      vecY = bY - middleY;
      px = -vecY;
      py = +vecX;
      controlX = middleX + px * balance;
      controlY = middleY + py * balance;
      return this.currentContext.quadraticCurveTo(controlX, controlY, bX, bY);
    },
    deflectionPoint: function(a, b, balance) {
      var aX, aY;
      aX = a.x();
      aY = a.y();
      return this.deflection(aX, aY, b.x(), b.y(), balance);
    },
    applyMargin: function(margin) {
      if (Ext.isString(margin)) {
        margin = margin.split(' ');
        if (margin.length === 4) {
          return {
            top: margin[0],
            right: margin[1],
            bottom: margin[2],
            left: margin[3]
          };
        } else if (margin.length === 2) {
          return {
            top: margin[0],
            right: margin[1],
            bottom: margin[0],
            left: margin[1]
          };
        }
      }
      if (Ext.isNumber(margin)) {
        return {
          top: margin,
          right: margin,
          bottom: margin,
          left: margin
        };
      }
      if (margin.left == null) {
        margin.left = 0;
      }
      if (margin.top == null) {
        margin.top = 0;
      }
      if (margin.bottom == null) {
        margin.bottom = 0;
      }
      if (margin.right == null) {
        margin.right = 0;
      }
      if (this.bounds != null) {
        this.calculateBoundsWithMargin();
      }
      return margin;
    },
    invalidate: function() {
      if (this.kineticShape != null) {
        return this.kineticShape.getStage().draw();
      }
    }
  });

}).call(this);

//# sourceMappingURL=ShapeWrapper.map
